\documentclass[10pt, onecolumn]{IEEEtran}

\usepackage[utf8]{inputenc}
\usepackage{geometry}
\usepackage{listings}
\usepackage{color}

\geometry{margin=0.75in}

\title{Writing Assignment 1}
\author{by Mihai Dan}
\date{October 16th, 2016}


\begin{document}

    \begin{center}
        \begin{minipage}[h]{\textwidth}
            \maketitle
        \end{minipage}
    \end{center}
    
    \begin{center}
        Operating Systems II - Fall 2016
    \end{center}
    
    \newpage

    \section*{Processes, Threads, and CPU Scheduling}
        In most basic terms, a process is an instance of a program that is being executed. Processes are the backbone of the operating system, as they carry out all necessary functions. Normally, processes contain executable code and process information, such as process ID and status. A thread is the smallest unit of processing that can be performed in an operating system. A process may consist of one or more threads running concurrently and executing specific operations. With limited resources and concurrent processes, efficient allocation of CPU usage is critical. The process of fair and efficient allocation is called CPU scheduling. Various methods of queueing and prioritization are implemented across different operating systems. The operating systems that will be further examined are Windows and FreeBSD, cross-referenced with Linux. As far as CPU scheduling, Windows uses the NT Class scheduler, FreeBSD uses the ULE Scheduler, and Linux uses the Completely Fair Scheduler (CFS). Along with the scheduling methods, process and thread handling will be dicussed in detail pertaining to each operating system.
        
    \subsection*{Processes}
        In a traditional operating system, processes are used for almost everything, from accomplishing a simple task to a convoluted series of commands. Processes are in separate address spaces, meaning there is no shared memory between them. Much like CPU scheduling, each operating system has a unique way of implementing process management. In Linux, processes are often referred to as tasks. Each process consists of a process ID, system resources allocated to it, a section of memory, security attributes, and processor state, which includes the contents of its registers and physical memory address. Processes get created on start up or by other processes, using the \texttt{fork();} command. The \texttt{fork();} command creates a duplicate process, with the process ID being the only difference. This exemplifies the Linux parent-child relationship, with the clone being child to the original process. The new process is placed in the active queue and scheduled for execution. The command associated with \texttt{fork();} is \texttt{exec();}. The \texttt{exec();} command will force the child process to execute a certain action. The parent process waits until the child process terminates to continue or exit. A process is the basic scheduling unit for Linux, which will be discussed in further detail under the \textit{CPU Scheduling} section. 
        
        \vspace{3mm}
        
        Similar to Linux, most processes have a parent processes in FreeBSD. Processes in FreeBSD consist of a process ID, parent process ID, signal state, real-time timers, tracing information, address space that has mappings of the program's object code and global variables, and kernel resources, including a descriptor array allowing access to files, pipes, sockets, and devices. A notable difference between the two operating systems is a process in FreeBSD must have at least one and possibly many threads to execute code. The threads are capable of performing specialized functions that are executed when prompted by the process. Processes in FreeBSD are created using the \texttt{fork();} command and executed using the \texttt{exec();} command, similar to Linux. In both in Linux and FreeBSD, processes can be terminated in several ways. The most common way is using the exit system call. Processes may also terminate voluntarily after completion, or terminated by the user. Regardless of exit method, the parent process receives the exit status of its child.
        
        \vspace{3mm}
        
        Windows implements a completely different approach for process management. Processes in Windows are represented by an executive process structure, or EPROCESS\cite{windowspt}. This process structure contains information relative to a process, as well as pointers to other necessary data structures. Components of a Windows process include a virtual address space, executable code, open handles to system objects, security context, unique process ID, environment variables, minimum and maximum working set sizes and  priority class, which will be discussed in the \textit{CPU Scheduling} section. Processes have a primary thread which executes the program, but may have multiple threads, depending on the complexity of the job. These threads are represented by the executive thread structure ETHREADS, which is explained in the \textit{Threads} section. In order to create a new process, a call must be made to the \texttt{CreateProcess();} function. Windows does not implement a parent-child relationship as a newly created process runs independently of the creating process. Below is a C++ implementation of the \texttt{CreateProcess();} function, as well as an explanation of its parameters.
        
        \lstset{language=C++,
                basicstyle=\ttfamily,
                keywordstyle=\color{blue}\ttfamily,
                stringstyle=\color{red}\ttfamily,
                commentstyle=\color{green}\ttfamily,
                morecomment=[l][\color{magenta}]{\#}
        }
        \begin{lstlisting}
            if( !CreateProcess( NULL,   // No module name (use command line)
                    argv[1],        // Command line
                    NULL,           // Process handle not inheritable
                    NULL,           // Thread handle not inheritable
                    FALSE,          // Set handle inheritance to FALSE
                    0,              // No creation flags
                    NULL,           // Use parent's environment block
                    NULL,           // Use parent's starting directory 
                    &si,            // Pointer to STARTUPINFO structure
                    &pi )           // Pointer to PROCESS_INFORMATION structure
            ){
                cout << "Process creation failed.";
                return 1;
            }
        \end{lstlisting}
        
        Once this function is called, several steps of validation must be taken before creating the process. These steps are as follows.
        
        \begin{enumerate}
            \item Check the parameters to make sure flags and options are valid.
            \item Prepare executable content for execution.
            \item Create Windows executive process object.
            \item Create initial thread. As previously mentioned, each process must at least have the primary thread of execution.
            \item Pass Windows executive object to the subsystem process to be initialized.
            \item Execute the initial thread.
            \item Process executes because of the initial thread.
        \end{enumerate}
        
        Windows process management relies heavily on the use of threads.A process can only be executed if prompted by the initial thread.
        
        
        
    \subsection*{Threads}
        Generally, a thread is the entity within the process which can be scheduled for execution. Linux provides a slightly different implementation by treating threads as "light weight processes." Threads are more efficient than processes as they share fundamental parts which processes do not. Reducing the overhead that comes with processes allows for more frequent and efficient context switching. Context switching is the procedure of keeping process state of concurrent processes, allowing the CPU to resume execution where it left off. This is important when allocating system resources, as process execution progression is recorded and stored. 
        
        \vspace{3mm}
        
        There are two types of threads in Linux, user-space and kernel-space threads\cite{linuxthread}. User-space threads avoid the kernel and manage the tables themselves. Each thread completes their quantum by calling an explicit switch, sending a signal or performing an action that involves the switcher. Additionally, a timer is implemented to terminate any process exceeding their quantum. User-space threads are created and manipulated with the \texttt{pthread} command found in the pthread library. Kernel-space threads are implemented in the kernel using several tables, allocating a task per table of threads. Threads are automatically scheduled within the quantum of each process. Kernel-space threads are created and manipulated by the \texttt{kthread} command, found in the LinuxThreads package. Processes may implement one or both thread types.
        
        \vspace{3mm}
        
        Being a UNIX based operating system, FreeBSD shares many thread properties with Linux. FreeBSD uses the same two types of threads, user-space and kernel-space. The structure of a thread slightly differs from that of a process, and is composed of the following components.
        
        \begin{enumerate}
            \item Scheduling - includes the priority, run state, and user-mode
            \item TSB - includes user-space and kernel-space execution states
            \item Kernel stack
            \item Machine state
        \end{enumerate}
    
        An important thing to note about UNIX based operating systems, such as FreeBSD, is that threads are simply processes with the ability to share resources with other processes.
        
        \vspace{3mm}
        
        Much like processes, Windows takes a different approach to thread management. Threads in Windows are represented by the executive thread structure, or ETHREADS\cite{windowspt}. Similarly to processes, in order to create a thread, a call must be made to the \texttt{CreateThread} function. The \texttt{CreateThread} function call instigates several calls to other functions.
        
        \begin{itemize}
            \item PspAllocateThread - creates and initializes of the executive thread object
            \item PspInsertThread - creates the thread handle and security information
            \item KeStartThread - converts executable thread object into ready-to-execute thread
        \end{itemize}
        
        Below is a C++ implementation of the \texttt{CreateThread} function, with parameters explained.
        
        \lstset{language=C++,
                basicstyle=\ttfamily,
                keywordstyle=\color{blue}\ttfamily,
                stringstyle=\color{red}\ttfamily,
                commentstyle=\color{green}\ttfamily,
                morecomment=[l][\color{magenta}]{\#}
                }
                
        \begin{lstlisting}
            hThreadArray[i] = CreateThread( 
                NULL,                   // default security attributes
                0,                      // use default stack size  
                MyThreadFunction,       // thread function name
                pDataArray[i],          // argument to thread function 
                0,                      // use default creation flags 
                &dwThreadIdArray[i]);   // returns the thread identifier 
        \end{lstlisting}
        
        After the function successfully completes, it informs Windows that a new thread is created and ready for execution.
    
    
    \subsection*{CPU Scheduling}
        As previously mentioned, CPU scheduling is handled differently across various operating systems. Linux implements the Completely Fair Scheduler (CFS). In the CFS, each processor has a separate run queue, with varying priority levels. A process may either be on the \textit{active} or \textit{expired} queue, depending on its state. The algorithm broken down into basic terms is as follows.
        
        \begin{enumerate}
            \item Find highest priority queue with a runnable process.
            \item Find the first process on selected queue.
            \item Calculate quantum size based on CPU usage and process priority.
            \item Execute program for quantum size.
            \item Once program completes, place it in the \textit{expired} queue.
        \end{enumerate}
        
        When the highest priority level pertaining to the \textit{active} queue contains no executable processes, the scheduler looks for the next highest priority queue. Once all \textit{active} queues are empty, the \textit{expired} queue becomes the \textit{active} queue. This allows for each process to be run once per cycle, treating each process fairly. When this happens, pointers pointed to the current array are switched to the next.
        
        \vspace{3mm}
        
        FreeBSD uses a similar scheduling system, but with a few notable differences. The ULE scheduler provides fair scheduling for processes and threads on FreeBSD\cite{ulesched}. A process is categorized by complexity and amount of I/O requests. The first notable difference between the two schedulers is that the ULE scheduler favors interactive programs, such as text editors. The reasoning behind this is because these processes exhibit short bursts of CPU usage in between waiting for user input. Much like CFS, the ULE Scheduler makes use of two queues, \textit{current} and \textit{next}. A process is categorized in either of these based on priority level and I/O intensity. Once all processes and threads in the \textit{current} queue have been executed, the \textit{current} queue is switched with the \textit{next}. Quantum size is dependent on CPU usage and priority level, and is recalculated every time a slice expires. 
        
        \vspace{3mm}
        
        As shown by the previous sections, Windows likes to do things differently. Threads are scheduled to execute based on their scheduling priority. There are 32 priority levels, from 0 being the lowest to 31 being the highest. The priority levels are also divided into two classes of scheduling, 1-15 being dynamic and 16-31 being fixed or real time. On top of priority levels, each process is assigned one of the following priority classes:
        
        \lstset{language=C++,
                    basicstyle=\ttfamily,
                    keywordstyle=\color{blue}\ttfamily,
                    stringstyle=\color{red}\ttfamily,
                    commentstyle=\color{green}\ttfamily,
                    morecomment=[l][\color{magenta}]{\#}
                }
                    
        \begin{lstlisting}
            IDLE_PRIORITY_CLASS
            BELOW_NORMAL_PRIORITY_CLASS
            NORMAL_PRIORITY_CLASS
            ABOVE_NORMAL_PRIORITY_CLASS
            HIGH_PRIORITY_CLASS
            REALTIME_PRIORITY_CLASS
        \end{lstlisting}
    
        The default priority class is \texttt{NORMAL\_PRIORITY\_CLASS}, but can be specified otherwise using the \texttt{CreateProcess} function.
        
        Thread priority is based on priority class of its process, as well as the process priority level. In order to allocate resources, the Round Robin scheduling technique is implemented, starting with the highest priority threads. Round Robin scheduling consists of assigning equal CPU time slices in a circular fashion. All threads with the same priority level are treated equally. Once a priority level is empty, the scheduler moves on to the next highest priority level. If a higher priority thread becomes available to run, system ceases the time slice for the currently running process. Another interesting feature provided by the Windows operating system is preemptive multitasking. Preemptive multitasking involves allocating CPU time slice size depending on CPU usage and priority level of process. Since this is done before execution, the system is aware of what to expect.
        
    \vspace{4mm}
    
    
    \section*{Comparison to Linux}
    
    \subsection*{Processes}
        Since FreeBSD and Linux are UNIX based systems, there aren't many differences in process management. Process structure is essentially the same amongst these operating systems. Also, both exhibit the parent-children relationship, using \texttt{fork();} to create new processes and \texttt{exec();} to execute them. The real difference is apparent between Windows and Linux. 
        Windows does not provide a parent-child relationship between processes, meaning they are independent of each other. Every time a call is made to \texttt{CreateProcess}, a new process must be created because of this independence. In Linux, the \texttt{fork():} creates an identical copy of the calling process, being more cost efficient. Another notable difference is that a process in Windows must have at least one thread of execution. Linux does not heavily rely on threads.
        
    \vspace{3mm}
    
    \subsection*{Threads}
        Similar to process management, thread management and structure are essentially the same in Linux and FreeBSD. The only evident difference is that FreeBSD threads are able to be managed by either the kernel or user space. Windows created their own way of creating, scheduling, and using threads, known as the executive thread structure. Threads are treated as a smaller means of execution, compared to a full size process. In Linux, threads are simply processes that can share resources, referred to as "light weight processes." There is no explicit thread management or scheduling implemented in Linux; the kernel treats them as processes. The Windows executive thread structure is more straightforward, but the Linux interpretation is easier to implement.
    
    \vspace{3mm}
    
    \subsection*{CPU Scheduling}
        As previously mentioned, Linux uses the Completely Fair Scheduler (CFS), FreeBSD uses the ULE scheduler, and Windows uses the NT class scheduler. While they may share characteristics, these schedulers are inherently different. The ULE scheduler relies heavily on queues and allocation of CPU time slices. Processes are assigned a priority level which determines start time of execution. The ULE scheduler prioritizes processes which request I/O, allowing for seemingly fast response time to user input. The CFS focuses more on how much time a process has spent in the CPU. In other words, the scheduler tries to allocate fair CPU usage time to each process. A notable difference between the CFS and the ULE scheduler is the program code length. The ULE scheduler code length is around 3000 lines, while the CFS is over 6000 lines
        As to no surprise, the Windows operating system implements a different method of CPU scheduling. Each process is assigned to a priority level (0 - 31), as well as a priority class, mentioned above. The scheduler performs Round Robin scheduling starting with the highest priority class thread in the highest priority level. This method is quite different than the Linux implementation because it heavily favors high priority processes, as opposed to fair distribution.
        
    \newpage
        
    \bibliographystyle{IEEEtran}
    \bibliography{cite.bib}

\end{document}
